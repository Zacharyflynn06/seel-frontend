"""
Tells the service this field/object has access authorized by an API key.
"""
directive @aws_api_key on FIELD_DEFINITION | OBJECT

"""Directs the schema to enforce authorization on a field"""
directive @aws_auth(
  """List of cognito user pool groups which have access on this field"""
  cognito_groups: [String]
) on FIELD_DEFINITION

"""
Tells the service this field/object has access authorized by a Cognito User Pools token.
"""
directive @aws_cognito_user_pools(
  """List of cognito user pool groups which have access on this field"""
  cognito_groups: [String]
) on FIELD_DEFINITION | OBJECT

"""
Tells the service this field/object has access authorized by sigv4 signing.
"""
directive @aws_iam on FIELD_DEFINITION | OBJECT

"""
Tells the service this field/object has access authorized by a Lambda Authorizer.
"""
directive @aws_lambda on FIELD_DEFINITION | OBJECT

"""
Tells the service this field/object has access authorized by an OIDC token.
"""
directive @aws_oidc on FIELD_DEFINITION | OBJECT

"""
Tells the service which subscriptions will be published to when this mutation is called. This directive is deprecated use @aws_susbscribe directive instead.
"""
directive @aws_publish(
  """
  List of subscriptions which will be published to when this mutation is called.
  """
  subscriptions: [String]
) on FIELD_DEFINITION

"""Tells the service which mutation triggers this subscription."""
directive @aws_subscribe(
  """
  List of mutations which will trigger this subscription when they are called.
  """
  mutations: [String]
) on FIELD_DEFINITION

"""This directive allows results to be deferred during execution"""
directive @defer on FIELD

"""
The `AWSDate` scalar type provided by AWS AppSync, represents a valid ***extended*** [ISO 8601 Date](https://en.wikipedia.org/wiki/ISO_8601#Calendar_dates) string. In other words, this scalar type accepts date strings of the form `YYYY-MM-DD`.  The scalar can also accept "negative years" of the form `-YYYY` which correspond to years before `0000`. For example, "**-2017-05-01**" and "**-9999-01-01**" are both valid dates.  This scalar type can also accept an optional [time zone offset](https://en.wikipedia.org/wiki/ISO_8601#Time_zone_designators). For example, "**1970-01-01**", "**1970-01-01Z**", "**1970-01-01-07:00**" and "**1970-01-01+05:30**" are all valid dates. The time zone offset must either be `Z` (representing the UTC time zone) or be in the format `±hh:mm:ss`. The seconds field in the timezone offset will be considered valid even though it is not part of the ISO 8601 standard.
"""
scalar AWSDate

"""
The `AWSDateTime` scalar type provided by AWS AppSync, represents a valid ***extended*** [ISO 8601 DateTime](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) string. In other words, this scalar type accepts datetime strings of the form `YYYY-MM-DDThh:mm:ss.SSSZ`.  The scalar can also accept "negative years" of the form `-YYYY` which correspond to years before `0000`. For example, "**-2017-01-01T00:00Z**" and "**-9999-01-01T00:00Z**" are both valid datetime strings.  The field after the two digit seconds field is a nanoseconds field. It can accept between 1 and 9 digits. So, for example, "**1970-01-01T12:00:00.2Z**", "**1970-01-01T12:00:00.277Z**" and "**1970-01-01T12:00:00.123456789Z**" are all valid datetime strings.  The seconds and nanoseconds fields are optional (the seconds field must be specified if the nanoseconds field is to be used).  The [time zone offset](https://en.wikipedia.org/wiki/ISO_8601#Time_zone_designators) is compulsory for this scalar. The time zone offset must either be `Z` (representing the UTC time zone) or be in the format `±hh:mm:ss`. The seconds field in the timezone offset will be considered valid even though it is not part of the ISO 8601 standard.
"""
scalar AWSDateTime

"""
The `AWSEmail` scalar type provided by AWS AppSync, represents an Email address string that complies with [RFC 822](https://www.ietf.org/rfc/rfc822.txt). For example, "**username@example.com**" is a valid Email address.
"""
scalar AWSEmail

"""
The `AWSIPAddress` scalar type provided by AWS AppSync, represents a valid [IPv4](https://en.wikipedia.org/wiki/IPv4#Addressing) or [IPv6](https://en.wikipedia.org/wiki/IPv6_address) address string.  IP addresses with subnet masks are considered valid. However, subnet masks are not necessary. For example, "**127.0.0.1**" and "**127.0.0.1/8**" are both considered valid IP Addresses.
"""
scalar AWSIPAddress

"""
The `AWSJSON` scalar type provided by AWS AppSync, represents a JSON string that complies with [RFC 8259](https://tools.ietf.org/html/rfc8259).  Maps like "**{\\"upvotes\\": 10}**", lists like "**[1,2,3]**", and scalar values like "**\\"AWSJSON example string\\"**", "**1**", and "**true**" are accepted as valid JSON and will automatically be parsed and loaded in the resolver mapping templates as Maps, Lists, or Scalar values rather than as the literal input strings.  Invalid JSON strings like "**{a: 1}**", "**{'a': 1}**" and "**Unquoted string**" will throw GraphQL validation errors.
"""
scalar AWSJSON

"""
The `AWSPhone` scalar type provided by AWS AppSync, represents a valid Phone Number. Phone numbers are serialized and deserialized as Strings. Segments of the phone number may be whitespace delimited or hyphenated.  The number can specify a country code at the beginning. However, United States numbers without country codes are still considered to be valid.
"""
scalar AWSPhone

"""
The `AWSTime` scalar type provided by AWS AppSync, represents a valid ***extended*** [ISO 8601 Time](https://en.wikipedia.org/wiki/ISO_8601#Times) string. In other words, this scalar type accepts time strings of the form `hh:mm:ss.SSS`.  The field after the two digit seconds field is a nanoseconds field. It can accept between 1 and 9 digits. So, for example, "**12:00:00.2**", "**12:00:00.277**" and "**12:00:00.123456789**" are all valid time strings. The seconds and nanoseconds fields are optional (the seconds field must be specified if the nanoseconds field is to be used).  This scalar type can also accept an optional [time zone offset](https://en.wikipedia.org/wiki/ISO_8601#Time_zone_designators). For example, "**12:30**", "**12:30Z**", "**12:30:24-07:00**" and "**12:30:24.500+05:30**" are all valid time strings. The time zone offset must either be `Z` (representing the UTC time zone) or be in the format `±hh:mm:ss`. The seconds field in the timezone offset will be considered valid even though it is not part of the ISO 8601 standard.
"""
scalar AWSTime

"""
The `AWSTimestamp` scalar type provided by AWS AppSync, represents the number of seconds that have elapsed since `1970-01-01T00:00Z`. Negative values are also accepted and these represent the number of seconds till `1970-01-01T00:00Z`.  Timestamps are serialized and deserialized as integers. The minimum supported timestamp value is **`-31557014167219200`** which corresponds to `-1000000000-01-01T00:00Z`. The maximum supported timestamp value is **`31556889864403199`** which corresponds to `1000000000-12-31T23:59:59.999999999Z`.
"""
scalar AWSTimestamp

"""
The `AWSURL` scalar type provided by AWS AppSync, represents a valid URL string (Ex: <https://www.amazon.com/>). The URL may use any scheme and may also be a local URL (Ex: <http://localhost/>).  URLs without schemes like "**amazon.com**" or "**www.amazon.com**" are considered invalid. URLs which contain double slashes (two consecutive forward slashes) in their path are also considered invalid.
"""
scalar AWSURL

"""  A Company is just a collection of attributes"""
type Company {
  attributes: [FieldValue!]!
  id: ID!
}

"""  Associates a value with its type and field"""
type CompanyAttribute {
  field: Field!
  value: FieldValue!
}

input CompanyAttributeIdInput {
  companyId: ID!
  fieldId: ID!
}

input DeleteInvestmentCriterionInput {
  fieldId: ID!
  investingEntityId: ID!
}

type Field {
  description: String!
  fieldType: FieldType!
  id: ID!
  name: String!
}

"""
  Represents a type that a user can associate with a custom field. This will be
 used for formatting the different internal postgres types to strings that will
 be displayed in the UI.
"""
type FieldType {
  description: String!

  """
    If not null, this is a format string suitable for a printf- or strfime-style
   function
  """
  formatString: String
  id: ID!

  """  Name must be unique across all users"""
  name: String!

  """  TODO: Indicates the GraphQL type this field is serialized with"""
  typeGraphQL: FieldValueType!

  """  Indicates the type of the DB column this value is stored in"""
  typePostgres: FieldTypePostgres!
}

"""
 ##############################################################################
                                    Fields                                   #
##############################################################################
 The type used to store this field in the DB
"""
enum FieldTypePostgres {
  BOOL
  DATE
  DOUBLE
  INT
  TEXT
  TIME
  TIMESTAMP
}

"""
  A Field's value can be serialized as any AppSync Scalar value. The AWS*
 extension Scalars are serialized as JavaScript strings.
"""
union FieldValue = FieldValueAWSDate | FieldValueAWSDateTime | FieldValueAWSEmail | FieldValueAWSIPAddress | FieldValueAWSJSON | FieldValueAWSPhone | FieldValueAWSTime | FieldValueAWSTimestamp | FieldValueAWSURL | FieldValueBoolean | FieldValueFloat | FieldValueInt | FieldValueString

"""  An extended ISO 8601 date string in the format YYYY-MM-DD."""
type FieldValueAWSDate {
  value: AWSDate!
  valueType: FieldValueType!
}

"""  An extended ISO 8601 date and time string in the format YYYY-MM-DDThh:mm:ss.sssZ.
"""
type FieldValueAWSDateTime {
  value: AWSDateTime!
  valueType: FieldValueType!
}

"""  An email address in the format local-part@domain-part as defined by RFC 822.
"""
type FieldValueAWSEmail {
  value: AWSEmail!
  valueType: FieldValueType!
}

"""
  A URL as defined by RFC 1738. For example,
 https://www.amazon.com/dp/B000NZW3KC/ or mailto:example@example.com. URLs must
 contain a schema (http, mailto) and can't contain two forward slashes (//) in
 the path part.
"""
type FieldValueAWSIPAddress {
  value: AWSIPAddress!
  valueType: FieldValueType!
}

"""
  A JSON string. Any valid JSON construct is automatically parsed and loaded in
 the resolver code as maps, lists, or scalar values rather than as the literal
 input strings. Unquoted strings or otherwise invalid JSON result in a GraphQL
 validation error.
"""
type FieldValueAWSJSON {
  value: AWSJSON!
  valueType: FieldValueType!
}

"""
  A phone number. This value is stored as a string. Phone numbers can contain
 either spaces or hyphens to separate digit groups. Phone numbers without a
 country code are assumed to be US/North American numbers adhering to the North
 American Numbering Plan (NANP).
"""
type FieldValueAWSPhone {
  value: AWSPhone!
  valueType: FieldValueType!
}

"""  An extended ISO 8601 time string in the format hh:mm:ss.sss."""
type FieldValueAWSTime {
  value: AWSTime!
  valueType: FieldValueType!
}

"""  An extended ISO 8601 date and time string in the format YYYY-MM-DDThh:mm:ss.sssZ.
"""
type FieldValueAWSTimestamp {
  value: AWSTimestamp!
  valueType: FieldValueType!
}

"""
  A URL as defined by RFC 1738. For example,
 https://www.amazon.com/dp/B000NZW3KC/ or mailto:example@example.com. URLs must
 contain a schema (http, mailto) and can't contain two forward slashes (//) in
 the path part.
"""
type FieldValueAWSURL {
  value: AWSURL!
  valueType: FieldValueType!
}

"""  A Boolean value, either true or false."""
type FieldValueBoolean {
  value: Boolean!
  valueType: FieldValueType!
}

"""  An IEEE 754 floating point value."""
type FieldValueFloat {
  value: Float!
  valueType: FieldValueType!
}

"""  Only one of these fields should be set"""
input FieldValueInput {
  boolean: Boolean
  date: AWSDate
  dateTime: AWSDateTime
  email: AWSEmail
  float: Float
  int: Int
  ipAddress: AWSIPAddress
  json: AWSJSON
  phone: AWSPhone
  string: String
  time: AWSTime
  timestamp: AWSTimestamp
  url: AWSURL
}

"""  An integer value between -(2^31) and 2^31-1."""
type FieldValueInt {
  value: Int!
  valueType: FieldValueType!
}

"""  A UTF-8 character sequence."""
type FieldValueString {
  value: String!
  valueType: FieldValueType!
}

"""
 ##############################################################################
                                   Company                                   #
##############################################################################
 Used as the Tag part of a tagged union
"""
enum FieldValueType {
  BOOLEAN
  DATE
  DATE_TIME
  EMAIL
  FLOAT
  INT
  IP_ADDRESS
  JSON
  PHONE
  STRING
  TIME
  TIMESTAMP
  URL
}

type InvestingEntity {
  address: String!
  entityType: InvestingEntityType!
  id: ID!
  investmentCriteria: [InvestmentCriterion!]!
  name: String!
  strategy: InvestingEntityStrategy!
  users: [User!]!
}

enum InvestingEntityStrategy {
  DIGITAL_ASSETS
  FUND_OF_FUNDS
  OTHER
  PRIVATE_DEBT
  PRIVATE_EQUITY
  REAL_ESTATE
  VENTURE_CAPITAL
}

"""
 ##############################################################################
                                     Fund                                    #
##############################################################################
"""
enum InvestingEntityType {
  FUND
  OTHER
  SERIES_LLC
  SPV
}

"""
 ##############################################################################
                         Investment Criteria                                 #
##############################################################################
 Joins an investing entity to a field. If required is true, then email ingester
 will reply to emails asking for this information.
"""
type InvestmentCriterion {
  field: Field!
  investingEntity: InvestingEntity!
  required: Boolean!
}

input KeyValuePair {
  key: String!
  value: String!
}

input LinkInvestingEntityToUserInput {
  investingEntityId: ID!
  userId: ID!
}

type Mutation {
  """ TODO"""
  deleteCompany(id: ID!): Company

  """ TODO"""
  deleteCompanyAttribute(input: CompanyAttributeIdInput!): CompanyAttribute
  deleteField(id: ID!): Field
  deleteFieldType(id: ID!): FieldType
  deleteInvestingEntity(id: ID!): InvestingEntity
  deleteInvestmentCriterion(input: DeleteInvestmentCriterionInput!): InvestmentCriterion
  deleteUser(id: ID!): User
  linkInvestingEntityToUser(input: LinkInvestingEntityToUserInput!): User
  unlinkInvestingEntityFromUser(input: UnlinkInvestingEntityFromUserInput!): User

  """ TODO"""
  upsertCompany(input: UpsertCompanyInput!): Company!

  """ TODO"""
  upsertCompanyAttribute(input: UpsertSingleCompanyAttributeInput!): CompanyAttribute!
  upsertField(input: UpsertFieldInput!): Field!
  upsertFieldType(input: UpsertFieldTypeInput!): FieldType!
  upsertInvestingEntity(input: UpsertInvestingEntityInput!): InvestingEntity!
  upsertInvestmentCriterion(input: UpsertInvestmentCriterionInput!): InvestmentCriterion!
  upsertUser(user: UpsertUserInput!): User!
}

type Query {
  addDocumentToCollectionUrl(collectionName: String!, metadata: [KeyValuePair]): String!
  ask(question: String!): String!
  askCollection(collectionName: String!, query: String!): String!
  documentUploadUrl(clientLookupName: String!, userId: String!): String!

  """  TODO"""
  getCompanies: [Company!]!

  """  TODO"""
  getCompany(id: ID!): Company

  """  TODO"""
  getCompanyAttribute(input: CompanyAttributeIdInput!): CompanyAttribute
  getField(id: ID!): Field
  getFieldType(id: ID!): FieldType
  getFieldTypes: [FieldType!]!
  getFields: [Field!]!
  getInvestingEntities: [InvestingEntity!]!
  getInvestingEntity(id: ID!): InvestingEntity
  getUser(id: ID!): User
  getUsers: [User!]!
}

input UnlinkInvestingEntityFromUserInput {
  investingEntityId: ID!
  userId: ID!
}

input UpsertCompanyAttributeInput {
  fieldId: ID!
  value: FieldValueInput!
}

input UpsertCompanyInput {
  attributes: [UpsertCompanyAttributeInput!]!
  id: ID
}

input UpsertFieldInput {
  description: String!
  fieldTypeId: ID!
  id: ID
  name: String!
}

input UpsertFieldTypeInput {
  description: String!
  formatString: String
  id: ID
  name: String!
  typeGraphQL: FieldValueType!
  typePostgres: FieldTypePostgres!
}

input UpsertInvestingEntityInput {
  address: String!
  entityType: InvestingEntityType!
  id: ID
  name: String!
  strategy: InvestingEntityStrategy!
}

input UpsertInvestmentCriterionInput {
  fieldId: ID!
  investingEntityId: ID!
  required: Boolean!
}

input UpsertSingleCompanyAttributeInput {
  companyId: ID!
  fieldId: ID!
  value: FieldValueInput!
}

input UpsertUserInput {
  email: String!
  id: String
}

"""
 ##############################################################################
                                     User                                    #
##############################################################################
"""
type User {
  email: String!
  id: String!
  investingEntities: [InvestingEntity!]!
}
