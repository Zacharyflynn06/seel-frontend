"""
Tells the service this field/object has access authorized by an API key.
"""
directive @aws_api_key on FIELD_DEFINITION | OBJECT

"""Directs the schema to enforce authorization on a field"""
directive @aws_auth(
  """List of cognito user pool groups which have access on this field"""
  cognito_groups: [String]
) on FIELD_DEFINITION

"""
Tells the service this field/object has access authorized by a Cognito User Pools token.
"""
directive @aws_cognito_user_pools(
  """List of cognito user pool groups which have access on this field"""
  cognito_groups: [String]
) on FIELD_DEFINITION | OBJECT

"""
Tells the service this field/object has access authorized by sigv4 signing.
"""
directive @aws_iam on FIELD_DEFINITION | OBJECT

"""
Tells the service this field/object has access authorized by a Lambda Authorizer.
"""
directive @aws_lambda on FIELD_DEFINITION | OBJECT

"""
Tells the service this field/object has access authorized by an OIDC token.
"""
directive @aws_oidc on FIELD_DEFINITION | OBJECT

"""
Tells the service which subscriptions will be published to when this mutation is called. This directive is deprecated use @aws_susbscribe directive instead.
"""
directive @aws_publish(
  """
  List of subscriptions which will be published to when this mutation is called.
  """
  subscriptions: [String]
) on FIELD_DEFINITION

"""Tells the service which mutation triggers this subscription."""
directive @aws_subscribe(
  """
  List of mutations which will trigger this subscription when they are called.
  """
  mutations: [String]
) on FIELD_DEFINITION

"""This directive allows results to be deferred during execution"""
directive @defer on FIELD

"""
The `AWSDate` scalar type provided by AWS AppSync, represents a valid ***extended*** [ISO 8601 Date](https://en.wikipedia.org/wiki/ISO_8601#Calendar_dates) string. In other words, this scalar type accepts date strings of the form `YYYY-MM-DD`.  The scalar can also accept "negative years" of the form `-YYYY` which correspond to years before `0000`. For example, "**-2017-05-01**" and "**-9999-01-01**" are both valid dates.  This scalar type can also accept an optional [time zone offset](https://en.wikipedia.org/wiki/ISO_8601#Time_zone_designators). For example, "**1970-01-01**", "**1970-01-01Z**", "**1970-01-01-07:00**" and "**1970-01-01+05:30**" are all valid dates. The time zone offset must either be `Z` (representing the UTC time zone) or be in the format `±hh:mm:ss`. The seconds field in the timezone offset will be considered valid even though it is not part of the ISO 8601 standard.
"""
scalar AWSDate

"""
The `AWSDateTime` scalar type provided by AWS AppSync, represents a valid ***extended*** [ISO 8601 DateTime](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) string. In other words, this scalar type accepts datetime strings of the form `YYYY-MM-DDThh:mm:ss.SSSZ`.  The scalar can also accept "negative years" of the form `-YYYY` which correspond to years before `0000`. For example, "**-2017-01-01T00:00Z**" and "**-9999-01-01T00:00Z**" are both valid datetime strings.  The field after the two digit seconds field is a nanoseconds field. It can accept between 1 and 9 digits. So, for example, "**1970-01-01T12:00:00.2Z**", "**1970-01-01T12:00:00.277Z**" and "**1970-01-01T12:00:00.123456789Z**" are all valid datetime strings.  The seconds and nanoseconds fields are optional (the seconds field must be specified if the nanoseconds field is to be used).  The [time zone offset](https://en.wikipedia.org/wiki/ISO_8601#Time_zone_designators) is compulsory for this scalar. The time zone offset must either be `Z` (representing the UTC time zone) or be in the format `±hh:mm:ss`. The seconds field in the timezone offset will be considered valid even though it is not part of the ISO 8601 standard.
"""
scalar AWSDateTime

"""
The `AWSEmail` scalar type provided by AWS AppSync, represents an Email address string that complies with [RFC 822](https://www.ietf.org/rfc/rfc822.txt). For example, "**username@example.com**" is a valid Email address.
"""
scalar AWSEmail

"""
The `AWSIPAddress` scalar type provided by AWS AppSync, represents a valid [IPv4](https://en.wikipedia.org/wiki/IPv4#Addressing) or [IPv6](https://en.wikipedia.org/wiki/IPv6_address) address string.  IP addresses with subnet masks are considered valid. However, subnet masks are not necessary. For example, "**127.0.0.1**" and "**127.0.0.1/8**" are both considered valid IP Addresses.
"""
scalar AWSIPAddress

"""
The `AWSJSON` scalar type provided by AWS AppSync, represents a JSON string that complies with [RFC 8259](https://tools.ietf.org/html/rfc8259).  Maps like "**{\\"upvotes\\": 10}**", lists like "**[1,2,3]**", and scalar values like "**\\"AWSJSON example string\\"**", "**1**", and "**true**" are accepted as valid JSON and will automatically be parsed and loaded in the resolver mapping templates as Maps, Lists, or Scalar values rather than as the literal input strings.  Invalid JSON strings like "**{a: 1}**", "**{'a': 1}**" and "**Unquoted string**" will throw GraphQL validation errors.
"""
scalar AWSJSON

"""
The `AWSPhone` scalar type provided by AWS AppSync, represents a valid Phone Number. Phone numbers are serialized and deserialized as Strings. Segments of the phone number may be whitespace delimited or hyphenated.  The number can specify a country code at the beginning. However, United States numbers without country codes are still considered to be valid.
"""
scalar AWSPhone

"""
The `AWSTime` scalar type provided by AWS AppSync, represents a valid ***extended*** [ISO 8601 Time](https://en.wikipedia.org/wiki/ISO_8601#Times) string. In other words, this scalar type accepts time strings of the form `hh:mm:ss.SSS`.  The field after the two digit seconds field is a nanoseconds field. It can accept between 1 and 9 digits. So, for example, "**12:00:00.2**", "**12:00:00.277**" and "**12:00:00.123456789**" are all valid time strings. The seconds and nanoseconds fields are optional (the seconds field must be specified if the nanoseconds field is to be used).  This scalar type can also accept an optional [time zone offset](https://en.wikipedia.org/wiki/ISO_8601#Time_zone_designators). For example, "**12:30**", "**12:30Z**", "**12:30:24-07:00**" and "**12:30:24.500+05:30**" are all valid time strings. The time zone offset must either be `Z` (representing the UTC time zone) or be in the format `±hh:mm:ss`. The seconds field in the timezone offset will be considered valid even though it is not part of the ISO 8601 standard.
"""
scalar AWSTime

"""
The `AWSTimestamp` scalar type provided by AWS AppSync, represents the number of seconds that have elapsed since `1970-01-01T00:00Z`. Negative values are also accepted and these represent the number of seconds till `1970-01-01T00:00Z`.  Timestamps are serialized and deserialized as integers. The minimum supported timestamp value is **`-31557014167219200`** which corresponds to `-1000000000-01-01T00:00Z`. The maximum supported timestamp value is **`31556889864403199`** which corresponds to `1000000000-12-31T23:59:59.999999999Z`.
"""
scalar AWSTimestamp

"""
The `AWSURL` scalar type provided by AWS AppSync, represents a valid URL string (Ex: <https://www.amazon.com/>). The URL may use any scheme and may also be a local URL (Ex: <http://localhost/>).  URLs without schemes like "**amazon.com**" or "**www.amazon.com**" are considered invalid. URLs which contain double slashes (two consecutive forward slashes) in their path are also considered invalid.
"""
scalar AWSURL

type Chat {
  documentCollection: DocumentCollection!
  history: [ChatMessage!]!
  id: ID!
  user: User!
}

type ChatMessage {
  response: String
  userMessage: String!
}

"""  A Company is just a collection of attributes"""
type Company {
  attributes: [CompanyAttribute!]!

  """  TODO"""
  documentCollections: [DocumentCollection!]!

  """  TODO"""
  documents: [DocumentMetadata!]!
  id: ID!
  investingEntity: InvestingEntity
}

"""  Associates a value with its type and field"""
type CompanyAttribute {
  field: Field!
  value: FieldValue!
}

input CompanyAttributeIdInput {
  companyId: ID!
  fieldId: ID!
}

input DeleteInvestmentCriterionInput {
  fieldId: ID!
  investingEntityId: ID!
}

type DocumentCollection {
  company: Company
  description: String
  documents: [DocumentMetadata!]!
  id: ID!
  investingEntity: InvestingEntity
  name: String!
  user: User
}

"""
 ##############################################################################
                                   Document                                  #
##############################################################################
"""
type DocumentMetadata {
  company: Company
  description: String

  """
    URL to download the body of this document. NULL if no document has
   been uploaded yet.
  """
  downloadUrl: AWSURL
  id: ID!
  investingEntity: InvestingEntity
  mimeType: String
  name: String!

  """
    URL to make a PUT request to with the body of the document. See:
   https://docs.aws.amazon.com/AmazonS3/latest/userguide/PresignedUrlUploadObject.html
  """
  uploadUrl: AWSURL!
  user: User
}

type Field {
  description: String!
  fieldType: FieldType!
  id: ID!
  name: String!
}

"""
  Represents a type that a user can associate with a custom field. This will be
 used for formatting the different internal postgres types to strings that will
 be displayed in the UI.
"""
type FieldType {
  description: String!

  """
    If not null, this is a format string suitable for a printf- or strfime-style
   function
  """
  formatString: String
  id: ID!

  """  Name must be unique across all users"""
  name: String!
  typeGraphQL: FieldValueType!
}

"""
 ##############################################################################
                                    Fields                                   #
##############################################################################
 The type used to store this field in the DB
"""
enum FieldTypePostgres {
  BOOL
  DATE
  DOUBLE
  INT
  TEXT
  TIME
  TIMESTAMP
}

"""
  A Field's value can be serialized as any AppSync Scalar value. The AWS*
 extension Scalars are serialized as JavaScript strings.
"""
type FieldValue {
  booleanValue: Boolean
  dateTimeValue: AWSDateTime
  dateValue: AWSDate
  emailValue: AWSEmail
  floatValue: Float
  intValue: Int
  ipAddressValue: AWSIPAddress
  jsonValue: AWSJSON
  phoneValue: AWSPhone
  stringValue: String
  timeValue: AWSTime
  timestampValue: AWSTimestamp
  urlValue: AWSURL
}

"""  Only one of these fields should be set"""
input FieldValueInput {
  boolean: Boolean
  date: AWSDate
  dateTime: AWSDateTime
  email: AWSEmail
  float: Float
  int: Int
  ipAddress: AWSIPAddress
  json: AWSJSON
  phone: AWSPhone
  string: String
  time: AWSTime
  timestamp: AWSTimestamp
  url: AWSURL
}

"""
 ##############################################################################
                                   Company                                   #
##############################################################################
 Used as the Tag part of a tagged union
"""
enum FieldValueType {
  BOOLEAN
  DATE
  DATE_TIME
  EMAIL
  FLOAT
  INT
  IP_ADDRESS
  JSON
  PHONE
  STRING
  TIME
  TIMESTAMP
  URL
}

type InvestingEntity {
  address: String!
  companies: [Company!]!

  """  TODO"""
  documentCollections: [DocumentCollection!]!

  """  TODO"""
  documents: [DocumentMetadata!]!
  entityType: InvestingEntityType!
  id: ID!
  investmentCriteria: [InvestmentCriterion!]!
  name: String!
  strategy: InvestingEntityStrategy!
  users: [User!]!
}

enum InvestingEntityStrategy {
  DIGITAL_ASSETS
  FUND_OF_FUNDS
  OTHER
  PRIVATE_DEBT
  PRIVATE_EQUITY
  REAL_ESTATE
  VENTURE_CAPITAL
}

"""
 ##############################################################################
                                     Fund                                    #
##############################################################################
"""
enum InvestingEntityType {
  FUND
  OTHER
  SERIES_LLC
  SPV
}

"""
 ##############################################################################
                         Investment Criteria                                 #
##############################################################################
 Joins an investing entity to a field. If required is true, then email ingester
 will reply to emails asking for this information.
"""
type InvestmentCriterion {
  field: Field!
  investingEntity: InvestingEntity!
  required: Boolean!
}

input LinkInvestingEntityToUserInput {
  investingEntityId: ID!
  userId: ID!
}

type Mutation {
  deleteCompany(id: ID!): Company
  deleteCompanyAttribute(input: CompanyAttributeIdInput!): CompanyAttribute
  deleteDocumentMetadata(id: ID!): DocumentMetadata
  deleteField(id: ID!): Field
  deleteFieldType(id: ID!): FieldType
  deleteInvestingEntity(id: ID!): InvestingEntity
  deleteInvestmentCriterion(input: DeleteInvestmentCriterionInput!): InvestmentCriterion
  deleteUser(id: ID!): User
  linkInvestingEntityToUser(input: LinkInvestingEntityToUserInput!): User
  unlinkInvestingEntityFromUser(input: UnlinkInvestingEntityFromUserInput!): User
  upsertCompany(input: UpsertCompanyInput!): Company!
  upsertCompanyAttribute(input: UpsertSingleCompanyAttributeInput!): CompanyAttribute!
  upsertDocumentMetadata(input: UpsertDocumentMetadataInput): DocumentMetadata
  upsertField(input: UpsertFieldInput!): Field!
  upsertFieldType(input: UpsertFieldTypeInput!): FieldType!
  upsertInvestingEntity(input: UpsertInvestingEntityInput!): InvestingEntity!
  upsertInvestmentCriterion(input: UpsertInvestmentCriterionInput!): InvestmentCriterion!
  upsertUser(user: UpsertUserInput!): User!
}

type Query {
  addDocumentToCollectionUrl(collectionName: String!): String!
  ask(question: String!): String!
  askCollection(collectionName: String!, query: String!): String!
  documentUploadUrl(clientLookupName: String!, userId: String!): String!
  getAllDocumentMetadata: [DocumentMetadata!]!
  getCompanies: [Company!]!
  getCompany(id: ID!): Company
  getCompanyAttribute(input: CompanyAttributeIdInput!): CompanyAttribute
  getField(id: ID!): Field
  getFieldType(id: ID!): FieldType
  getFieldTypes: [FieldType!]!
  getFields: [Field!]!
  getInvestingEntities: [InvestingEntity!]!
  getInvestingEntity(id: ID!): InvestingEntity
  getSingleDocumentMetadata(id: ID!): DocumentMetadata
  getUser(id: ID!): User
  getUsers: [User!]!
}

input UnlinkInvestingEntityFromUserInput {
  investingEntityId: ID!
  userId: ID!
}

input UpsertCompanyAttributeInput {
  fieldId: ID!
  value: FieldValueInput!
}

input UpsertCompanyInput {
  attributes: [UpsertCompanyAttributeInput!]!

  """
    If specified, indicates the ID of the company to update. If this
   is not specified, then an investingEntityId must be provided.
  """
  id: ID

  """
    If `id` is not given, this is used to create a new Company
   associated with this investing entity
  """
  investingEntityId: ID
}

input UpsertDocumentMetadataInput {
  companyId: ID
  description: String

  """  If provided, the upsert request modifies an existing document."""
  id: ID
  investingEntityId: ID

  """
    If this is not provided, the back end will infer a meme type after
   uploading a new file.
  """
  mimeType: String
  name: String!
  userId: ID
}

input UpsertFieldInput {
  description: String!
  fieldTypeId: ID!
  id: ID
  name: String!
}

input UpsertFieldTypeInput {
  description: String!
  formatString: String
  id: ID
  name: String!
  typeGraphQL: FieldValueType!
  typePostgres: FieldTypePostgres!
}

input UpsertInvestingEntityInput {
  address: String!
  entityType: InvestingEntityType!
  id: ID
  name: String!
  strategy: InvestingEntityStrategy!
}

input UpsertInvestmentCriterionInput {
  fieldId: ID!
  investingEntityId: ID!
  required: Boolean!
}

input UpsertSingleCompanyAttributeInput {
  """
    If specified, indicates the ID of the company to update. If this
   is not specified, then an investingEntityId must be provided.
  """
  companyId: ID
  fieldId: ID!

  """
    If `id` is not given, this is used to create a new Company
   associated with this investing entity
  """
  investingEntityId: ID
  value: FieldValueInput!
}

input UpsertUserInput {
  email: String!
  id: String
}

"""
 ##############################################################################
                                     User                                    #
##############################################################################
"""
type User {
  """  TODO"""
  documentCollections: [DocumentCollection!]!

  """  TODO"""
  documents: [DocumentMetadata!]!
  email: String!
  id: String!
  investingEntities: [InvestingEntity!]!
}
